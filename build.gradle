plugins {
	id 'java-library'
	id 'org.springframework.boot' version '3.5.3'
	id 'io.spring.dependency-management' version '1.1.7'
	id 'org.graalvm.buildtools.native' version '0.10.6'
	id 'org.asciidoctor.jvm.convert' version '4.0.3'
	id 'org.openrewrite.rewrite' version '7.9.0'
	id 'org.jreleaser' version '1.19.0'
	id 'com.javiersc.semver' version '0.8.0'
}

group = 'org.sc.ai'
version = '0.0.1-SNAPSHOT'
description = 'sc cli - simple ai for everyday people'

// Configure semver for alpha releases
semver {
    tagPrefix.set("v")
}

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(22)
	}
	modularity.inferModulePath = true
}

repositories {
	mavenCentral()
}

ext {
	set('springAiVersion', "1.0.0")
    set('scVersion', project.version)
    set('picocliVersion', "4.7.7")
    set('jlineVersion', "3.30.0")
}

configurations {
    generateConfig
}

dependencies {
    api 'org.springframework.boot:spring-boot-starter'
    api('org.springframework.ai:spring-ai-starter-model-ollama') {
        exclude group: 'org.springframework.boot', module: 'spring-boot-starter-webflux'
    }
	api 'org.springframework.ai:spring-ai-starter-model-chat-memory-repository-jdbc'
	api 'org.springframework.ai:spring-ai-pdf-document-reader'
	api 'org.springframework.ai:spring-ai-markdown-document-reader'
	api 'org.springframework.ai:spring-ai-jsoup-document-reader'
    api 'org.springframework.ai:spring-ai-vector-store'
	api "org.jline:jline:${jlineVersion}"
	api "org.jline:jline-terminal-ffm:${jlineVersion}"
	api "org.jline:jline-terminal-jni:${jlineVersion}"
    api "info.picocli:picocli-spring-boot-starter:${picocliVersion}"
	api "info.picocli:picocli-shell-jline3:${picocliVersion}"
	annotationProcessor "info.picocli:picocli-codegen:${picocliVersion}"
    generateConfig "info.picocli:picocli-codegen:${picocliVersion}"
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.ai:spring-ai-spring-boot-testcontainers'
	testImplementation 'org.testcontainers:ollama:1.21.0'
    testImplementation 'org.awaitility:awaitility'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    
    // OpenRewrite dependencies
    rewrite 'org.openrewrite:rewrite-java:8.56.0'
    rewrite 'org.openrewrite.recipe:rewrite-spring:6.9.0'
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.ai:spring-ai-bom:${springAiVersion}"
	}
}

// JReleaser configuration
jreleaser {
    configFile = file('jreleaser.yml')
}

tasks.named('test') {
	useJUnitPlatform()
}

springBoot {
    buildInfo {
		properties {
			additional = [
				'description' : project.getDescription(),
			]
		}
	}
}

jar {
    manifest {
        attributes('Automatic-Module-Name': 'org.sc.ai.cli')
    }
    archiveClassifier = 'plain'
}

bootJar {
    manifest {
        attributes('Automatic-Module-Name': 'org.sc.ai.cli')
    }
    
    // Enable layered jars for efficient packaging and Docker builds
    layered {
        enabled = true
    }
    
    // Optimize for startup performance
    archiveClassifier = ''
    
    // Enable efficient jar structure for jpackage
    requiresUnpack '**/spring-*.jar'
}

// AOT (Ahead-of-Time) compilation for faster startup
tasks.named("processAot") {
    // Enable AOT processing for production builds
    enabled = true
}

// Optimize Spring Boot for jpackage distribution
tasks.named("bootJar") {
    // Ensure AOT processing runs before bootJar
    dependsOn "processAot"
    
    // Configure for optimal jpackage performance
    doFirst {
        logger.info("Building optimized JAR for jpackage distribution")
    }
}

compileJava {
    options.compilerArgs += ["-Aproject=${project.group}/${project.name}"]
    options.javaModuleVersion = provider { project.version.toString() }
}

task generateManpageAsciiDoc(type: JavaExec) {
    dependsOn(classes)
    group = "Documentation"
    description = "Generate AsciiDoc manpage"
    classpath = configurations.generateConfig + sourceSets.main.runtimeClasspath
    mainClass = 'picocli.codegen.docgen.manpage.ManPageGenerator'
    args 'org.sc.ai.cli.command.DocumentationTopCommand', "--outdir=${project.buildDir}/generated-picocli-docs", "-v"
}

task generateManpageTemplates(type: JavaExec) {
    dependsOn(classes)
    group = "Documentation"
    description = "Generate AsciiDoc manpage templates (run only once to create templates)"
    classpath = configurations.generateConfig + sourceSets.main.runtimeClasspath
    mainClass = 'picocli.codegen.docgen.manpage.ManPageGenerator'
    args 'org.sc.ai.cli.command.DocumentationTopCommand', 
         "--outdir=${project.buildDir}/generated-picocli-docs", 
         "--template-dir=src/docs/man-templates",
         "--force",
         "-v"
}

task generateEnhancedDocs(type: JavaExec) {
    dependsOn(classes)
    group = "Documentation"
    description = "Generate documentation using templates (if they exist) or standard generation"
    classpath = configurations.generateConfig + sourceSets.main.runtimeClasspath
    mainClass = 'picocli.codegen.docgen.manpage.ManPageGenerator'
    
    doFirst {
        def templatesDir = file("src/docs/man-templates")
        if (templatesDir.exists() && templatesDir.listFiles().length > 0) {
            println "Using existing templates from: ${templatesDir}"
            args 'org.sc.ai.cli.command.DocumentationTopCommand', 
                 "--outdir=${project.buildDir}/generated-picocli-docs", 
                 "-v"
        } else {
            println "No templates found, using standard generation"
            args 'org.sc.ai.cli.command.DocumentationTopCommand', 
                 "--outdir=${project.buildDir}/generated-picocli-docs", 
                 "-v"
        }
    }
}

asciidoctor {
    dependsOn(generateEnhancedDocs)
    
    // Determine source directory based on whether templates exist
    def templatesDir = file("src/docs/man-templates")
    if (templatesDir.exists() && templatesDir.listFiles().length > 0) {
        sourceDir = templatesDir
        println "Using templates from: ${templatesDir}"
    } else {
        sourceDir = file("${project.buildDir}/generated-picocli-docs")
        println "Using generated docs from: ${project.buildDir}/generated-picocli-docs"
    }
    
    outputDir = file("${project.buildDir}/docs")
    logDocuments = true
    outputOptions {
        backends = ['html5']
    }
    attributes = [
        'source-highlighter': 'coderay',
        'icons': 'font',
        'includedir': "${project.buildDir}/generated-picocli-docs"
    ]
}

task generateDocs {
    dependsOn(asciidoctor)
    group = "Documentation"
    description = "Generate all documentation (AsciiDoc man pages converted to HTML)"
    doLast {
        // Copy schema files to docs directory
        mkdir("${project.buildDir}/docs/schemas")
        copy {
            from ".sc/schema.json"
            into "${project.buildDir}/docs/schemas"
        }
        
        println "Documentation generated in: ${project.buildDir}/docs"
        println "Available files:"
        file("${project.buildDir}/docs").listFiles().each { file ->
            if (file.name.endsWith('.html')) {
                println "  - ${file.name}"
            }
        }
        println "Schema files:"
        file("${project.buildDir}/docs/schemas").listFiles().each { file ->
            println "  - schemas/${file.name}"
        }
    }
}

graalvmNative {
    binaries {
        main {
            imageName = 'sc'
            buildArgs.add('--verbose')
        }
    }
    metadataRepository {
        enabled = true
    }
}

// JPackage tasks for local development
task jpackageDeb {
    group = "JPackage"
    description = "Build optimized DEB package using jpackage"
    dependsOn bootJar
    doLast {
        exec {
            commandLine './gradlew', 'jreleaserAssemble', '--assembler=jpackage'
        }
    }
}

task jpackageDmg {
    group = "JPackage"
    description = "Build optimized DMG package using jpackage (macOS only)"
    dependsOn bootJar
    doLast {
        exec {
            commandLine './gradlew', 'jreleaserAssemble', '--assembler=jpackage'
        }
    }
}

task jpackageExe {
    group = "JPackage"
    description = "Build optimized EXE package using jpackage (Windows only)"
    dependsOn bootJar
    doLast {
        exec {
            commandLine './gradlew', 'jreleaserAssemble', '--assembler=jpackage'
        }
    }
}

// Extract jar task for optimal jpackage performance
task extractJar {
    group = "JPackage"
    description = "Extract executable jar for optimal jpackage performance"
    dependsOn bootJar
    
    doLast {
        def jarFile = bootJar.archiveFile.get().asFile
        def extractDir = file("${buildDir}/extracted")
        
        // Clean extract directory
        delete extractDir
        mkdir extractDir
        
        // Extract using Spring Boot's built-in tool
        exec {
            workingDir extractDir
            commandLine 'java', '-Djarmode=tools', '-jar', jarFile.absolutePath, 'extract'
        }
        
        logger.info("Extracted jar to: ${extractDir}")
        logger.info("Use extracted jar for jpackage: ${extractDir}/${jarFile.name}")
    }
}

// Custom jpackage task to bypass JReleaser issues
task buildJPackageInstaller(type: Exec) {
    dependsOn bootJar
    group = "Distribution"
    description = "Build platform-specific installer using jpackage"
    
    doFirst {
        def osName = System.getProperty("os.name").toLowerCase()
        def isWindows = osName.contains("windows")
        def isMac = osName.contains("mac")
        def isLinux = osName.contains("linux")
        
        def outputDir = file("${buildDir}/jpackage")
        outputDir.mkdirs()
        
        def jarDir = file("${buildDir}/libs")
        def mainJar = file("${buildDir}/libs/${project.name}-${project.version}.jar")
        
        def versionString = project.version.toString()
        // Convert semver to jpackage-compatible version (max 3 numbers)
        def cleanVersion = versionString
            .replace('-SNAPSHOT', '')
            .replaceAll(/\+.*$/, '') // Remove build metadata
            .replaceAll(/-.*$/, '') // Remove pre-release identifiers
        // Ensure it has at most 3 components and starts with 1 (not 0)
        def versionParts = cleanVersion.split('\\.')
        if (versionParts[0] == '0') {
            versionParts[0] = '1' // jpackage requires first component to be >= 1
        }
        def jpackageVersion = versionParts.take(3).join('.')
        
        // Determine platform and architecture for naming
        def platform = isWindows ? "windows" : (isMac ? "macos" : "linux")
        def arch = System.getProperty("os.arch").toLowerCase()
        if (arch.contains("amd64") || arch.contains("x86_64")) {
            arch = "x64"
        } else if (arch.contains("aarch64") || arch.contains("arm64")) {
            arch = "arm64"
        }
        
        def baseArgs = [
            'jpackage',
            '--input', jarDir.absolutePath,
            '--name', 'sc',
            '--main-jar', mainJar.name,
            '--main-class', 'org.sc.ai.cli.ChatbotApplication',
            '--dest', outputDir.absolutePath,
            '--app-version', jpackageVersion,
            '--vendor', 'Julius Krah',
            '--description', 'sc cli - simple ai for everyday people',
            '--copyright', 'Copyright 2025 Julius Krah',
            '--java-options', '-Xmx2G',
            '--java-options', '-Dspring.profiles.active=prod'
        ]
        
        if (isWindows) {
            commandLine baseArgs + [
                '--type', 'msi',
                '--win-dir-chooser',
                '--win-menu',
                '--win-shortcut'
            ]
        } else if (isMac) {
            commandLine baseArgs + [
                '--type', 'pkg'
            ]
        } else if (isLinux) {
            commandLine baseArgs + [
                '--type', 'deb',
                '--linux-menu-group', 'Utility',
                '--linux-shortcut'
            ]
        } else {
            throw new GradleException("Unsupported operating system: ${osName}")
        }
    }
    
    doLast {
        // Rename the generated files to follow the naming convention
        def osName = System.getProperty("os.name").toLowerCase()
        def isWindows = osName.contains("windows")
        def isMac = osName.contains("mac")
        def isLinux = osName.contains("linux")
        
        def platform = isWindows ? "windows" : (isMac ? "macos" : "linux")
        def arch = System.getProperty("os.arch").toLowerCase()
        if (arch.contains("amd64") || arch.contains("x86_64")) {
            arch = "x64"
        } else if (arch.contains("aarch64") || arch.contains("arm64")) {
            arch = "arm64"
        }
        
        def outputDir = file("${buildDir}/jpackage")
        def versionString = project.version.toString()
        
        // Find and rename generated files
        outputDir.listFiles().each { file ->
            if (file.isFile()) {
                def extension = file.name.substring(file.name.lastIndexOf('.'))
                def newName = "sc_v${versionString}_${platform}_${arch}${extension}"
                def newFile = new File(outputDir, newName)
                
                if (file.renameTo(newFile)) {
                    logger.info("Renamed ${file.name} to ${newName}")
                } else {
                    logger.warn("Failed to rename ${file.name} to ${newName}")
                }
            }
        }
        
        logger.info("JPackage installer created in: ${outputDir}")
    }
}

// Release tasks
task releaseAlpha {
    group = "Release"
    description = "Create an alpha release"
    doLast {
        exec {
            commandLine './gradlew', 'createSemverTag', '-Psemver.stage=alpha', '-Psemver.scope=auto'
        }
    }
}

task releaseBeta {
    group = "Release"
    description = "Create a beta release"
    doLast {
        exec {
            commandLine './gradlew', 'createSemverTag', '-Psemver.stage=beta', '-Psemver.scope=auto'
        }
    }
}

task releaseRC {
    group = "Release"
    description = "Create a release candidate"
    doLast {
        exec {
            commandLine './gradlew', 'createSemverTag', '-Psemver.stage=rc', '-Psemver.scope=auto'
        }
    }
}

task releaseFinal {
    group = "Release"
    description = "Create a final release"
    doLast {
        exec {
            commandLine './gradlew', 'createSemverTag', '-Psemver.stage=final', '-Psemver.scope=auto'
        }
    }
}

task jreleaserFullReleaseLocal {
    group = "JReleaser"
    description = "Run JReleaser full release with dry-run for testing"
    doLast {
        exec {
            commandLine './gradlew', 'jreleaserFullRelease', '--dry-run'
        }
    }
}

rewrite {
    activeRecipe 'com.simplecommerce.ai.commerce.PackageMigrationRecipe'
    configFile = file('rewrite.yml')
}

task migratePackages {
    dependsOn 'rewriteRun'
    group = "Migration"
    description = "Migrate package structure from org.simplecommerce.ai.commerce to org.sc.ai.cli"
    doLast {
        println "Package migration completed!"
        println "Please review the changes and run './gradlew clean build' to verify everything works correctly."
    }
}

task previewPackageMigration {
    dependsOn 'rewriteDryRun'
    group = "Migration"
    description = "Preview package migration changes without applying them"
    doLast {
        println "Migration preview completed!"
        println "Review the output above to see what changes would be made."
        println "Run './gradlew migratePackages' to apply the changes."
    }
}
